"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.OAuth = exports.PKCEClient = void 0;
const node_crypto_1 = require("node:crypto");
const image_1 = require("./image");
const bus_1 = require("./bus");
var OauthRedirectMethod;
(function (OauthRedirectMethod) {
    /**
     * Use this type for a redirect back to the Raycast website, which will then open the extension.
     * In the OAuth app, configure `https://raycast.com/redirect?packageName=Extension`
     * (This is a static redirect URL for all extensions.)
     * If the provider does not accept query parameters in redirect URLs, you can alternatively use `https://raycast.com/redirect/extension`
     * and then customize the {@link OAuth.AuthorizationRequest} via its `extraParameters` property. For example add:
     *  `extraParameters: { "redirect_uri": "https://raycast.com/redirect/extension" }`
     */
    OauthRedirectMethod["Web"] = "web";
    /**
     * Use this type for an app-scheme based redirect that directly opens Raycast.
     * In the OAuth app, configure `raycast://oauth?package_name=Extension`
     */
    OauthRedirectMethod["App"] = "app";
    /**
     * Use this type for a URI-style app scheme that directly opens Raycast.
     * In the OAuth app, configure `com.raycast:/oauth?package_name=Extension`
     * (Note the single slash - Google, for example, would require this flavor for an OAuth app where the Bundle ID is `com.raycast`)
     */
    OauthRedirectMethod["AppURI"] = "appURI";
})(OauthRedirectMethod || (OauthRedirectMethod = {}));
class PKCEClient {
    redirectMethod;
    providerName;
    providerIcon;
    providerId;
    description;
    resolvesOnRedirect;
    isAuthorizing;
    constructor(options) {
        this.providerId = options.providerId;
        this.providerName = options.providerName;
        this.providerIcon = options.providerIcon;
        this.description = options.description;
        this.redirectMethod = options.redirectMethod;
        this.resolvesOnRedirect = false;
        this.isAuthorizing = false;
    }
    buildAuthUrl(options, state, codeChallenge, redirectURI) {
        const params = new URLSearchParams({
            response_type: "code",
            client_id: options.clientId,
            redirect_uri: redirectURI,
            scope: options.scope,
            state: state,
            code_challenge: codeChallenge,
            code_challenge_method: "S256",
            ...options.extraParameters,
        });
        return `${options.endpoint}?${params}`;
    }
    getRedirectURI() {
        switch (this.redirectMethod) {
            case exports.OAuth.RedirectMethod.Web:
                return "https://raycast.com/redirect?packageName=Extension";
            case exports.OAuth.RedirectMethod.App:
                return "raycast://oauth?package_name=Extension";
            case exports.OAuth.RedirectMethod.AppURI:
                return "com.raycast:/oauth?package_name=Extension";
        }
    }
    /**
     * Creates an authorization request for the provided authorization endpoint, client ID, and scopes.
     * You need to first create the authorization request before calling {@link OAuth.PKCEClient.authorize}.
     *
     * @remarks The generated code challenge for the PKCE request uses the S256 method.
     *
     * @returns A promise for an {@link OAuth.AuthorizationRequest} that you can use as input for {@link OAuth.PKCEClient.authorize}.
     */
    async authorizationRequest(options) {
        const codeVerifier = (0, node_crypto_1.randomBytes)(32).toString("base64url");
        const codeChallenge = (0, node_crypto_1.createHash)("sha256")
            .update(codeVerifier)
            .digest("base64url");
        const state = Buffer.from(JSON.stringify({
            flavor: "release",
            id: (0, node_crypto_1.randomUUID)(),
            providerName: this.providerName,
        })).toString("base64url");
        const redirectURI = this.getRedirectURI();
        return {
            state,
            codeChallenge,
            codeVerifier,
            redirectURI,
            toURL: () => this.buildAuthUrl(options, state, codeChallenge, redirectURI),
        };
    }
    /**
     * Starts the authorization and shows the OAuth overlay in Raycast.
     * As parameter you can either directly use the returned request from {@link OAuth.PKCEClient.authorizationRequest},
     * or customize the URL by extracting parameters from {@link OAuth.AuthorizationRequest} and providing your own URL via {@link AuthorizationOptions}.
     * Eventually the URL will be used to open the authorization page of the provider in the web browser.
     *
     * @returns A promise for an {@link OAuth.AuthorizationResponse}, which contains the authorization code needed for the token exchange.
     * The promise is resolved when the user was redirected back from the provider's authorization page to the Raycast extension.
     */
    async authorize(options) {
        const isAuthorizationOptions = (s) => {
            return typeof s.url === "string";
        };
        const res = await bus_1.bus.turboRequest("oauth.authorize", {
            client: {
                id: this.providerId,
                description: this.description ?? "Connect to your account",
                name: this.providerName,
                icon: this.providerIcon
                    ? (0, image_1.serializeProtoImage)(this.providerIcon)
                    : undefined,
            },
            url: isAuthorizationOptions(options) ? options.url : options.toURL(),
        });
        if (!res.ok) {
            throw res.error;
        }
        return { authorizationCode: res.value.code };
    }
    authorizationURL;
    /**
     * Securely stores a {@link OAuth.TokenSet} for the provider. Use this after fetching the access token from the provider.
     * If the provider returns a a standard OAuth JSON token response, you can directly pass the {@link OAuth.TokenResponse}.
     * At a minimum, you need to set the {@link OAuth.TokenSet.accessToken}, and typically you also set {@link OAuth.TokenSet.refreshToken} and {@link OAuth.TokenSet.isExpired}.
     * Raycast automatically shows a logout preference for the extension when a token set was saved.
     *
     * @remarks If you want to make use of the convenience {@link OAuth.TokenSet.isExpired} method, the property {@link OAuth.TokenSet.expiresIn} must be configured.
     *
     * @returns A promise that resolves when the token set has been stored.
     */
    async setTokens(options) {
        const isTokenResponse = (options) => {
            return Object.hasOwn(options, "access_token");
        };
        if (isTokenResponse(options)) {
            await bus_1.bus.turboRequest("oauth.setTokens", {
                accessToken: options.access_token,
                refreshToken: options.refresh_token,
                idToken: options.id_token,
                scope: options.scope,
                expiresIn: options.expires_in,
                providerId: this.providerId,
            });
        }
        else {
            await bus_1.bus.turboRequest("oauth.setTokens", {
                ...options,
                providerId: this.providerId,
            });
        }
    }
    /**
     * Retrieves the stored {@link OAuth.TokenSet} for the client.
     * You can use this to initially check whether the authorization flow should be initiated or
     * the user is already logged in and you might have to refresh the access token.
     *
     * @returns A promise that resolves when the token set has been retrieved.
     */
    async getTokens() {
        const res = await bus_1.bus.turboRequest("oauth.getTokens", {
            providerId: this.providerId,
        });
        const set = res.unwrap().tokenSet;
        if (!set)
            return undefined;
        const tokenSet = {
            accessToken: set.accessToken,
            refreshToken: set.refreshToken,
            scope: set.scope,
            idToken: set.idToken,
            updatedAt: new Date(set.updatedAt * 1000),
            expiresIn: set.expiresIn,
            isExpired: () => {
                return !!(tokenSet.expiresIn &&
                    tokenSet.updatedAt.getTime() + tokenSet.expiresIn * 1000 < Date.now());
            },
        };
        return tokenSet;
    }
    /**
     * Removes the stored {@link OAuth.TokenSet} for the client.
     */
    async removeTokens() {
        await bus_1.bus.turboRequest("oauth.removeTokens", {
            providerId: this.providerId,
        });
    }
}
exports.PKCEClient = PKCEClient;
exports.OAuth = {
    PKCEClient,
    RedirectMethod: OauthRedirectMethod,
};
