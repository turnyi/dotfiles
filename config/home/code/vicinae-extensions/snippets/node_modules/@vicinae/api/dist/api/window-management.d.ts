import { Application } from "./proto/application";
import * as wm from "./proto/wm";
/**
 * Access Vicinae's window management features.
 *
 * @remarks
 * Window management support varies a lot depending on the environment.
 * Right now it is pretty well supported on almost all linux desktop environments except KDE.
 *
 * @example
 * ```typescript
 * import { WindowManagement } from '@vicinae/api';
 *
 * const wins = await WindowManagement.getWindows();
 * const browserWindow = wins.find(w => w.application?.name?.includes('firefox'));
 *
 * if (browserWindow) {
 *  await browserWindow.focus();
 * }
 * ```
 *
 * @category Window Management
 * @public
 */
export declare namespace WindowManagement {
    /**
     * A window as defined by the windowing system in use.
     * A window can be optionally tied to an application or a workspace.
     */
    type Window = {
        id: string;
        title: string;
        /**
         * Whether this window is currently active.
         * This is usually the window that currently owns focus.
         */
        active: boolean;
        bounds: {
            position: {
                x: number;
                y: number;
            };
            size: {
                height: number;
                width: number;
            };
        };
        /**
         * The ID of the workspace this window belongs to, if applicable in the context
         * of the current window manager.
         */
        workspaceId?: string;
        /**
         * The application this window belongs to, if any.
         */
        application?: Application;
        /**
         * Request that the window manager focuses this window.
         * @see {@link focusWindow}
         */
        focus: () => Promise<boolean>;
    };
    type Workspace = {
        id: string;
        name: string;
        monitorId: string;
        active: boolean;
    };
    /**
     * A screen, physical or virtual, attached to this computer.
     */
    type Screen = {
        /**
         * Name assigned by the windowing system to that screen.
         *
         * In Wayland environments for instance, the name is set to something like `DP-1`, `DP-2`, `e-DP1`...
         *
         * @remarks The name is not guaranteed to remain stable but is usually stable enough to uniquely identify a screen.
         */
        name: string;
        /**
         * Name of the screen's manufacturer.
         */
        make: string;
        model: string;
        /**
         * The serial number of the screen, if available.
         */
        serial?: string;
        bounds: {
            position: {
                x: number;
                y: number;
            };
            size: {
                width: number;
                height: number;
            };
        };
    };
    function getWindows(options?: wm.GetWindowsRequest): Promise<WindowManagement.Window[]>;
    /**
     * Focus `window`.
     *
     * @remarks
     * Window objects have a {@link Window.focus} method that can be used to achieve the same thing on a specific window directly.
     *
     * @param window - the window to focus. You may want to make sure this window still exists when you request focus.
     *
     * @return `true` if the window was focused, `false` otherwise.
     * A window may not have been focused because it doesn't accept focus (e.g some layer shell surfaces)
     * or simply because it doesn't exist anymore.
     *
     * @see {@link Window.focus}
     */
    function focusWindow(window: Window): Promise<boolean>;
    /**
     * Return the list of screens (physical and virtual) currently attached to the computer.
     */
    function getScreens(): Promise<Screen[]>;
    function getActiveWorkspace(): Promise<WindowManagement.Workspace>;
    function getWorkspaces(): Promise<WindowManagement.Workspace[]>;
    function getWindowsOnActiveWorkspace(): Promise<WindowManagement.Window[]>;
    function setWindowBounds(payload: wm.SetWindowBoundsRequest): Promise<void>;
    function getActiveWindow(): Promise<WindowManagement.Window>;
}
