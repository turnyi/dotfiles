"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.WindowManagement = void 0;
const bus_1 = require("./bus");
const transformWorkspace = (proto) => {
    return {
        id: proto.id,
        name: proto.name,
        active: proto.active,
        monitorId: proto.monitor,
    };
};
const transformWindow = (proto) => {
    return {
        id: proto.id,
        title: proto.title,
        workspaceId: proto.workspaceId,
        active: proto.active,
        bounds: {
            position: { x: proto.x, y: proto.y },
            size: { width: proto.width, height: proto.height },
        },
        application: proto.app,
        focus() {
            return WindowManagement.focusWindow(this);
        },
    };
};
/**
 * Access Vicinae's window management features.
 *
 * @remarks
 * Window management support varies a lot depending on the environment.
 * Right now it is pretty well supported on almost all linux desktop environments except KDE.
 *
 * @example
 * ```typescript
 * import { WindowManagement } from '@vicinae/api';
 *
 * const wins = await WindowManagement.getWindows();
 * const browserWindow = wins.find(w => w.application?.name?.includes('firefox'));
 *
 * if (browserWindow) {
 *  await browserWindow.focus();
 * }
 * ```
 *
 * @category Window Management
 * @public
 */
var WindowManagement;
(function (WindowManagement) {
    async function getWindows(options = {}) {
        const res = await bus_1.bus.request("wm.getWindows", options);
        return res.unwrap().windows.map(transformWindow);
    }
    WindowManagement.getWindows = getWindows;
    /**
     * Focus `window`.
     *
     * @remarks
     * Window objects have a {@link Window.focus} method that can be used to achieve the same thing on a specific window directly.
     *
     * @param window - the window to focus. You may want to make sure this window still exists when you request focus.
     *
     * @return `true` if the window was focused, `false` otherwise.
     * A window may not have been focused because it doesn't accept focus (e.g some layer shell surfaces)
     * or simply because it doesn't exist anymore.
     *
     * @see {@link Window.focus}
     */
    async function focusWindow(window) {
        const res = await bus_1.bus.request("wm.focusWindow", {
            id: window.id,
        });
        return res.unwrap().ok;
    }
    WindowManagement.focusWindow = focusWindow;
    /**
     * Return the list of screens (physical and virtual) currently attached to the computer.
     */
    async function getScreens() {
        const res = await bus_1.bus.request("wm.getScreens", {});
        return res.unwrap().screens.map((sc) => ({
            name: sc.name,
            make: sc.make,
            model: sc.model,
            serial: sc.serial,
            bounds: {
                position: { x: sc.x, y: sc.y },
                size: { width: sc.width, height: sc.height },
            },
        }));
    }
    WindowManagement.getScreens = getScreens;
    async function getActiveWorkspace() {
        const res = await bus_1.bus.request("wm.getActiveWorkspace", {});
        return transformWorkspace(res.unwrap().workspace);
    }
    WindowManagement.getActiveWorkspace = getActiveWorkspace;
    async function getWorkspaces() {
        const res = await bus_1.bus.request("wm.getWorkspaces", {});
        return res.unwrap().workspaces.map(transformWorkspace);
    }
    WindowManagement.getWorkspaces = getWorkspaces;
    async function getWindowsOnActiveWorkspace() {
        const workspace = await getActiveWorkspace();
        return getWindows({ workspaceId: workspace.id });
    }
    WindowManagement.getWindowsOnActiveWorkspace = getWindowsOnActiveWorkspace;
    async function setWindowBounds(payload) {
        await bus_1.bus.request("wm.setWindowBounds", payload);
    }
    WindowManagement.setWindowBounds = setWindowBounds;
    async function getActiveWindow() {
        const res = await bus_1.bus.request("wm.getActiveWindow", {});
        return transformWindow(res.unwrap().window);
    }
    WindowManagement.getActiveWindow = getActiveWindow;
})(WindowManagement || (exports.WindowManagement = WindowManagement = {}));
