"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Application = exports.showInFileBrowser = exports.getDefaultApplication = exports.getApplications = exports.getFrontmostApplication = exports.open = exports.runInTerminal = exports.trash = void 0;
const promises_1 = require("node:fs/promises");
const bus_1 = require("./bus");
const window_management_1 = require("./window-management");
/**
  @ignore - we should probably move this to raycast compat, I don't think we want that.
 */
const trash = async (path) => {
    const targets = Array.isArray(path) ? path : [path];
    const promises = targets.map((p) => (0, promises_1.rm)(p, { recursive: true }));
    await Promise.all(promises);
};
exports.trash = trash;
/**
 * Run a command in a new terminal emulator window.
 *
 * @param args - the command line to execute. This is *not* getting interpreted by a shell.
 * @param options - list of options that can be passed in order to tweak the behavior of the terminal window.
 *
 * @example
 * ```typescript
 * await runInTerminal(['journalctl', '--user', '-u', '-f', 'vicinae']);
 * // or, inside a shell:
 * await runInTerminal(['/bin/bash', 'echo "dis is my home: $HOME"'], { hold: true });
 * ```
 *
 * @category System
 */
const runInTerminal = async (args, options = {}) => {
    const { hold = false, appId, title } = options;
    await bus_1.bus.request("app.runInTerminal", {
        cmdline: args,
        hold,
        appId,
        title,
    });
};
exports.runInTerminal = runInTerminal;
/**
 * @category System
 */
const open = async (target, app) => {
    let appId;
    if (app) {
        if (typeof app === "string") {
            appId = app;
        }
        else {
            appId = app.id;
        }
    }
    await bus_1.bus.request("app.open", {
        target,
        appId,
    });
};
exports.open = open;
/**
 * @category System
 */
const getFrontmostApplication = async () => {
    const { application } = await window_management_1.WindowManagement.getActiveWindow();
    if (!application) {
        throw new Error(`Could not get frontmost application`);
    }
    return application;
};
exports.getFrontmostApplication = getFrontmostApplication;
/**
 * @category System
 */
const getApplications = async (target) => {
    const res = await bus_1.bus.request("app.list", { target });
    return res.unwrap().apps;
};
exports.getApplications = getApplications;
/**
 * @category System
 */
const getDefaultApplication = async (path) => {
    const res = await bus_1.bus.request("app.getDefault", { target: path });
    const app = res.unwrap().app;
    if (!app)
        throw new Error(`No default application for target ${path}`);
    return app;
};
exports.getDefaultApplication = getDefaultApplication;
/**
 * @category System
 */
const showInFileBrowser = async (path) => {
    const fileBrowser = await (0, exports.getDefaultApplication)("inode/directory"); // FIXME: we may want something more robust
    await (0, exports.open)(path.toString(), fileBrowser);
};
exports.showInFileBrowser = showInFileBrowser;
var application_1 = require("./proto/application");
Object.defineProperty(exports, "Application", { enumerable: true, get: function () { return application_1.Application; } });
