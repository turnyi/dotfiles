import events from "node:events";
interface FSWatchOptions {
    interval: number;
}
export interface TailOptions {
    separator?: string | RegExp | null;
    fsWatchOptions?: FSWatchOptions;
    follow?: boolean;
    logger?: DevNull;
    useWatchFile?: boolean;
    flushAtEOF?: boolean;
    encoding?: BufferEncoding;
    fromBeginning?: boolean;
    nLines?: number;
    /**
     * Create an empty file if it does not exist.
     */
    forceCreate?: boolean;
}
declare class DevNull {
    info(...args: any): void;
    error(...args: any): void;
}
export declare class Tail extends events.EventEmitter {
    private filename;
    private absPath;
    private separator?;
    private fsWatchOptions;
    private follow;
    private logger;
    private useWatchFile;
    private flushAtEOF;
    private encoding;
    private nLines?;
    private rewatchId;
    private isWatching;
    private queue;
    private buffer;
    private watcher;
    private internalDispatcher;
    private currentCursorPos;
    constructor(filename: string, options?: TailOptions);
    /**
     * Grabs the index of the last line of text in the format /.*(\n)?/.
     * Returns null if a full line can not be found.
     * @param {string} text
     * @returns {number | null}
     */
    private getIndexOfLastLine;
    /**
     * Returns the position of the start of the `nLines`th line from the bottom.
     * Returns 0 if `nLines` is greater than the total number of lines in the file.
     * @param {number} nLines
     * @returns {number}
     */
    private getPositionAtNthLine;
    private latestPosition;
    private readBlock;
    private change;
    watch(startingCursor: number, flush?: boolean): void;
    private rename;
    private watchEvent;
    private watchFileEvent;
    unwatch(): void;
}
export {};
